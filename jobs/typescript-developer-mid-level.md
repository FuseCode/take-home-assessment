# TypeScript Developer (Mid-Level) — Practical Exercise (≤ 4 hours)

## Goal

Build a small **Catalog & Stock** service in **TypeScript** with strong typing, clean REST APIs, and a few real-world HTTP/data patterns:

* **Idempotent create** (via `Idempotency-Key`)
* **ETag / If-None-Match** for `GET /products/:id`
* **Keyset (cursor) pagination** for listing
* **Tenant scoping**
* Simple **stock movements** with a computed stock level

Keep it compact and production-minded.

---

## Tech (suggested, not mandatory)

* **Node.js** (18+), **TypeScript**
* Web framework: **Fastify** or **Express**
* ORM: **Prisma / TypeORM / Drizzle** (your choice)
* DB: **PostgreSQL** (preferred) — **SQLite** acceptable if time is tight
* Validation: **zod** or **class-validator**
* Tests: **Jest** or **Vitest** + **Supertest**
* API docs: OpenAPI via swagger plugin or a minimal YAML/JSON checked into the repo

---

## Domain & Schema

### `products`

* `id` UUID (PK)
* `tenant_id` TEXT
* `sku` TEXT (unique **per tenant**)
* `name` TEXT
* `price_cents` INT
* `version` INT (start at 1; bump on update)
* `created_at`, `updated_at` TIMESTAMPTZ

### `stock_movements`

* `id` UUID (PK)
* `tenant_id` TEXT
* `product_id` UUID (FK to `products`)
* `delta` INT (positive = in, negative = out)
* `reason` TEXT
* `created_at` TIMESTAMPTZ

### `idempotency_keys`

* `tenant_id` TEXT
* `key` TEXT
* `response_json` JSON
* `created_at` TIMESTAMPTZ
  **Unique:** `(tenant_id, key)`

Indexes you deem useful (e.g., `(tenant_id, created_at desc)`) are a plus.

---

## Endpoints

1. **POST `/products`** — create (idempotent)

   * **Headers:**

     * `Authorization: Bearer <anything>` *or* `X-Tenant-Id: <tenant>` (pick one; document choice)
     * `Idempotency-Key: <string>` (required)
   * **Body:** `{ "sku": "ABC-1", "name": "Widget", "priceCents": 1999 }`
   * **Rules:**

     * Create product for the tenant.
     * Same `Idempotency-Key` + **same body** within 1h → **200 replay** (same response).
     * Same key + **different body** → **409** `{ code:"conflict", message:"..." }`.
     * `sku` must be unique per tenant.
   * **Response:** `{ id, tenantId, sku, name, priceCents, version, createdAt }`

2. **GET `/products/:id`** — supports **ETag / If-None-Match**

   * Generate an **ETag** from a stable representation (e.g., `hash(id, sku, name, priceCents, version, updatedAt)`)
   * If `If-None-Match` matches the current ETag → **304** (no body)
   * Otherwise return the product and an `ETag` header

3. **GET `/products?search=&limit=10&cursor=<opaque>`** — **keyset pagination**

   * Sort by `created_at DESC, id DESC`
   * `search` filters by `sku` or `name` (case-insensitive contains) within the tenant
   * **Response:** `{ items:[...], nextCursor:"..." }` where `cursor` encodes the last `(created_at, id)`
   * Must be **stable**: no duplicates/omissions when paging

4. **POST `/products/:id/stock-movements`** — add movement

   * **Body:** `{ "delta": -3, "reason": "shipped" }`
   * Validate `delta != 0`
   * Insert a movement row for this product/tenant
   * **Response:** `{ id, productId, delta, reason, createdAt }`

5. **GET `/products/:id/stock-level`**

   * Returns the **computed** stock level: sum of `delta` for this product/tenant
   * **Response:** `{ productId, stockLevel }`

---

## Cross-cutting

* **Tenant scoping:** All queries must filter by the current tenant.
* **Validation:** Strong DTO/schema validation with helpful error messages.
* **Error model:** Non-2xx mapped to `{ code, message }` (and optional `details`).
* **OpenAPI:** Autogenerated or a small static spec—keep field names consistent.
* **Project layout:** sensible structure (controllers/routes, services, data, tests).

---

## Tests (write a few meaningful ones)

1. **Idempotency**

   * Same `Idempotency-Key` + same body → same product `id` returned
   * Same key + different body → **409**

2. **ETag / If-None-Match**

   * First `GET` returns `ETag`; second `GET` with `If-None-Match` → **304**
   * After an update (optional), ETag changes; `GET` returns 200

3. **Pagination**

   * Create ≥15 products; list with `limit=10` → returns 10 then 5 items, **no duplicates**

4. **Stock level**

   * Apply movements (+5, -2) → `stockLevel` == 3 for that product/tenant

5. **Tenant isolation**

   * Same `sku` allowed across **different** tenants; stock levels do not leak

*(Aim for \~6–10 tests total. SQLite is acceptable for tests.)*

---

## Deliverables

* Repository with:

  * `src/` (app, routes/controllers, services, db/orm models)
  * `tests/` (Jest/Vitest + Supertest)
  * Migrations for your ORM **or** a bootstrap SQL
  * `README.md` with quick start, env vars, and a short cURL sequence
* Optional: `docker-compose.yml` for Postgres

---

## Timebox Guidance (≤ 4 hours)

Prioritize:

1. Product create (**idempotent**)
2. `GET /products/:id` with **ETag**
3. `GET /products` **keyset pagination**
4. Stock movements + stock level
5. Tests & README

---

## Evaluation Rubric (100 pts)

* **HTTP & data correctness (35)** — idempotency, ETag/304, stable pagination, stock math, tenant scoping
* **Type-safety & code quality (20)** — clean types, validation, structure, readability
* **Testing (20)** — useful integration tests, clear assertions
* **Data & SQL (15)** — schema choices, constraints, indexes, migrations or bootstrap
* **DX & Docs (10)** — easy run, clear README, sensible defaults

### Bonus (not required)

* Conditional requests for list (`If-Modified-Since` or `Last-Modified`)
* Lightweight request logging with a correlation id
* Minimal `/health` & `/ready` endpoints
