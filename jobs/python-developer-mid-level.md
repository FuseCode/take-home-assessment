# Python/FastAPI Developer (Mid-Level) — Practical Exercise (≤ 4 hours)

## Goal

Build a small **Orders API** with **idempotent create**, **optimistic locking on update**, **keyset pagination**, and a minimal **transactional outbox** table. Keep it production-minded but compact.

## Requirements

### Tech

* **FastAPI** (async)
* **Pydantic v2**
* **SQLAlchemy 2.x (async)** + **Alembic** (or a simple SQL bootstrap if time is tight)
* **PostgreSQL** (preferred)

  > If setting up Postgres will exceed time, you may use SQLite for the run, but keep SQLAlchemy models/migrations ready for Postgres.
* **pytest** (+ `pytest-asyncio`) and **httpx** for tests

### Domain (minimal)

**orders** table:

* `id` (UUID, PK)
* `tenant_id` (TEXT)
* `status` (`draft | confirmed | closed`)
* `version` (INT, starts at 1)
* `total_cents` (INT, nullable until confirmed)
* `created_at`, `updated_at` (timestamps)

**outbox** table:

* `id` (UUID, PK)
* `event_type` (TEXT) — e.g., `orders.closed`
* `order_id` (UUID)
* `tenant_id` (TEXT)
* `payload` (JSON)
* `published_at` (nullable timestamp) — you don’t need a publisher; just write the row.

### Endpoints

1. **POST `/orders`** — create draft

   * Headers: `Idempotency-Key: <string>` (required)
   * Body: `{ "tenantId": "alpha" }`
   * Behavior:

     * Create a **draft** order for the tenant.
     * **Idempotent** for 1 hour: the same key + same body → **200 replay** of the original response (not a new row).
     * Same key + different body → **409** with `{ code:"conflict", message:"..." }`.
   * Response: `{ id, tenantId, status, version, createdAt }`

2. **PATCH `/orders/{id}`** — confirm (set total)

   * Headers: `If-Match: "<version>"` (required; optimistic locking)
   * Body: `{ "totalCents": 1234 }`
   * Allowed transitions: `draft → confirmed`.
   * On stale `If-Match`, return **409** `{ code:"conflict", message:"stale version" }`.
   * Response includes updated `version` (increment by 1).

3. **POST `/orders/{id}/close`** — close & outbox

   * Preconditions: status must be `confirmed`.
   * In **the same transaction**:

     * Set status to `closed`, bump `version`.
     * Insert one **outbox** row with `event_type="orders.closed"` and a payload `{ orderId, tenantId, totalCents, closedAt }`.
   * Response: `{ id, status:"closed", version }`.

4. **GET `/orders?limit=10&cursor=<opaque>`** — keyset pagination

   * Sort: `created_at DESC, id DESC`.
   * Return `{ items:[...], nextCursor:"..." }` where `cursor` encodes the last `(created_at, id)`.
   * Must be **stable** (no duplicates/omissions when paging).

### Cross-cutting

* **Auth (dev-simple):** Accept `Authorization: Bearer <any>`, parse a fake JWT (or header) to extract `tenant_id`. If you’d rather not parse, allow a header `X-Tenant-Id` for the exercise (document which one you chose). All queries must be **tenant-scoped**.
* **Error model:** `{ code, message }` for non-2xx.
* **OpenAPI:** Autogenerated by FastAPI is fine; ensure schemas/field names match responses.
* **README:** One-page instructions to run, test, and a cURL sequence.

## Tests (write a few, they matter)

* **Idempotency:**

  * Same `Idempotency-Key` + same body → same order id.
  * Same key + different body → 409.
* **Optimistic locking:**

  * Confirm with correct `If-Match` succeeds; stale `If-Match` → 409.
* **Close + outbox (transactional):**

  * After closing, one row exists in outbox for that order; status is `closed`.
* **Pagination:**

  * Create ≥15 orders; fetch pages (limit=10) → 10 then 5 items, no duplicates.

*(Aim for \~8–12 concise tests.)*

## Deliverables

* Repo with:

  * `/app` (FastAPI app + models + routes)
  * `/migrations` (Alembic) or `schema.sql`
  * `/tests` (pytest)
  * `README.md` with run commands (venv/poetry/pip), env vars, and cURL examples
* Optional: a simple `Makefile` or `justfile` (`run`, `test`, `migrate`)

## Timebox & Scope Guidance

* Target **3–4 hours**. Prefer correctness and clarity over breadth.
* If time is tight, prioritize:

  1. Create (idempotent)
  2. Confirm (optimistic locking)
  3. Close + outbox (same transaction)
  4. Pagination
  5. Tests & README

## Evaluation Rubric (100 pts)

* **Correctness & domain rules (35)** — idempotency, optimistic locking, transactional outbox, pagination stability.
* **Code quality (20)** — structure, typing, naming, simplicity, comments where needed.
* **Testing (20)** — meaningful cases, async use, clear assertions.
* **Data & SQL (15)** — schema choices, indexes for pagination, migrations or clear bootstrap.
* **DX & Docs (10)** — easy to run, clear README, sensible defaults.

### Bonus (not required)

* Basic **OpenTelemetry** span around each handler.
* Simple **unique index** for idempotency keys (e.g., `(tenant_id, key)` with stored response).
* Docker/Compose setup.
